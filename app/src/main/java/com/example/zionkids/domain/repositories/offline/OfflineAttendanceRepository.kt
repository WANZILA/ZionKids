package com.example.zionkids.domain.repositories.offline


import android.content.Context
import com.example.zionkids.core.di.AttendanceRef
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import com.google.android.gms.tasks.Task
import com.google.android.gms.tasks.Tasks
import com.google.firebase.Timestamp
import com.example.zionkids.data.model.Attendance
import com.example.zionkids.data.model.AttendanceStatus
import com.example.zionkids.data.model.Child
import com.example.zionkids.data.local.dao.AttendanceDao
import com.example.zionkids.core.sync.attendance.AttendanceSyncScheduler // call enqueueNow after local writes
import com.google.firebase.firestore.CollectionReference
import com.google.firebase.firestore.Query
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.util.Calendar

// Keep the same DTO so UI doesn‚Äôt change.
data class AttendanceSnapshot(
    val attendance: List<Attendance>,
    val fromCache: Boolean,
    val hasPendingWrites: Boolean
)

data class EligibleCounts(
    val totalEligible: Int,
    val presentEligible: Int
)

interface OfflineAttendanceRepository {

//    suspend fun getStatusForChildOnce(childId: String, eventId: String): AttendanceStatus?
    suspend fun upsertAttendance(att: Attendance): String
    fun enqueueUpsertAttendance(att: Attendance)
    fun streamAttendanceForEvent(eventId: String): Flow<AttendanceSnapshot>
    fun streamAttendanceForChild(childId: String): Flow<AttendanceSnapshot>
    suspend fun getAttendanceOnce(eventId: String): List<Attendance>
    suspend fun getStatusForChildOnce(childId: String, eventId: String): AttendanceStatus?
    suspend fun getPresentAttendanceOnce(eventId: String): List<Attendance>
    suspend fun getAbsentAttendanceOnce(eventId: String): List<Attendance>
    fun markAllInBatchChunked(
        eventId: String,
        adminId: String,
        children: List<Child>,
        existing: Map<String, Attendance?>,
        status: AttendanceStatus,
        chunkSize: Int = 400
    ): Task<Void>

    // üëá NEW: pull remote rows for a single event into Room (marks clean)
    suspend fun hydrateEvent(eventId: String)

    suspend fun eligibleCountsForEvent(
        eventId: String,
        eventDate: Timestamp
    ): EligibleCounts
}

/**
 * Offline-first implementation:
 * - Reads come from Room.
 * - Writes go to Room (markDirty + version bump); worker will push.
 * - After any local change, we nudge AttendanceSyncScheduler.enqueueNow().
 *
 * DAO expectations (mirror your EventDao patterns):
 *   - suspend fun upsert(a: Attendance)
 *   - suspend fun upsertAll(list: List<Attendance>)
 *   - suspend fun getOnce(id: String): Attendance?
 *   - suspend fun getByEvent(eventId: String): List<Attendance>
 *   - suspend fun getByEventAndStatus(eventId: String, status: AttendanceStatus): List<Attendance>
 *   - suspend fun getForChild(childId: String): List<Attendance>
 *   - fun observeByEvent(eventId: String): Flow<List<Attendance>>
 *   - fun observeByChild(childId: String): Flow<List<Attendance>>
 *   - suspend fun markDirty(id: String, now: Timestamp)
 */
@Singleton
class OfflineAttendanceRepositoryImpl @Inject constructor(
    private val dao: AttendanceDao,
    @ApplicationContext private val appContext: Context,
    @AttendanceRef private val attendanceRef: CollectionReference,

    ) : OfflineAttendanceRepository {

    // inside OfflineAttendanceRepositoryImpl
    private val repoScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    private fun idFor(eventId: String, childId: String) = "${eventId}_${childId}"



    override suspend fun upsertAttendance(att: Attendance): String {
        val id = att.attendanceId.ifBlank { idFor(att.eventId, att.childId) }
        val now = Timestamp.now()

        val current = dao.getOnce(id)
        val nextVersion = (current?.version ?: 0L) + 1L

        // Preserve createdAt if present; otherwise keep att.createdAt
        val createdAt = current?.createdAt ?: att.createdAt

        val toSave = att.copy(
            attendanceId = id,
            createdAt = createdAt,
            updatedAt = now,
            checkedAt = att.checkedAt, // caller‚Äôs check time
            version = nextVersion,
            isDirty = true
        )

        dao.upsert(toSave)
        AttendanceSyncScheduler.enqueueNow(appContext) // üöÄ push soon
        return id
    }

//    override fun enqueueUpsertAttendance(att: Attendance) {
//        // Fire-and-forget local write. This runs in caller scope; your use-sites usually call from a coroutine.
//        // If you want guaranteed background, wrap in app-scope coroutine.
//        val id = att.attendanceId.ifBlank { idFor(att.eventId, att.childId) }
//        val now = Timestamp.now()
//
//        // Best-effort (non-suspending) via Kotlin‚Äôs runCatching + Room‚Äôs main-safety (Room is main-safe for suspend; for non-suspend, ensure it‚Äôs off main).
//        // Most callers will call this from a ViewModel coroutine‚Äîso it‚Äôs fine. If not, prefer the suspend path.
//        try {
//            val createdAt = att.createdAt
//            // Minimal bump: we don‚Äôt know current version here, so set +1 from 0; worker/merge can reconcile.
//            val toSave = att.copy(
//                attendanceId = id,
//                updatedAt = now,
//                createdAt = createdAt,
//                version = (att.version.takeIf { it > 0 } ?: 0L) + 1L,
//                isDirty = true
//            )
//            // If your DAO only exposes suspend upsert, call from a coroutine at call-site; otherwise add a non-suspend @Insert(onConflict=REPLACE).
//            // Here we assume suspend; most app code uses the suspend path primarily.
//            // noop: encourage callers to use suspend upsertAttendance(...)
//        } finally {
//            AttendanceSyncScheduler.enqueueNow(appContext)
//        }
//    }

    override fun enqueueUpsertAttendance(att: Attendance) {
        val id  = att.attendanceId.ifBlank { idFor(att.eventId, att.childId) }
        val now = Timestamp.now()

        repoScope.launch {
            val current = dao.getOnce(id)
            val toSave = att.copy(
                attendanceId = id,
                createdAt = current?.createdAt ?: att.createdAt,
                updatedAt = now,
                checkedAt = att.checkedAt,
                version = (current?.version ?: 0L) + 1L,
                isDirty = true
            )
            Timber.i("ATT/UPSERT ‚Üí id=%s v=%d e=%s c=%s", id, toSave.version, toSave.eventId, toSave.childId)
            dao.upsert(toSave)
            val roundTrip = dao.getOnce(id)
            Timber.i("ATT/READBACK ‚Üê id=%s status=%s version=%d", id, roundTrip?.status, roundTrip?.version ?: -1)
            AttendanceSyncScheduler.enqueueNow(appContext)
        }
    }


    override fun streamAttendanceForEvent(eventId: String): Flow<AttendanceSnapshot> =
        dao.observeByEvent(eventId).map { list ->
            AttendanceSnapshot(
                attendance = list,
                fromCache = true,              // Room = local cache
                hasPendingWrites = list.any { it.isDirty }
            )
        }

    override fun streamAttendanceForChild(childId: String): Flow<AttendanceSnapshot> =
        dao.observeByChild(childId).map { list ->
            AttendanceSnapshot(
                attendance = list,
                fromCache = true,
                hasPendingWrites = list.any { it.isDirty }
            )
        }

    override suspend fun getAttendanceOnce(eventId: String): List<Attendance> =
        dao.getByEvent(eventId)

    // Repo
    override suspend fun getStatusForChildOnce(childId: String, eventId: String): AttendanceStatus? =
        dao.getOneForChildAtEvent(eventId, childId)?.status

    override suspend fun getPresentAttendanceOnce(eventId: String): List<Attendance> =
        dao.getByEventAndStatus(eventId, AttendanceStatus.PRESENT)

    override suspend fun getAbsentAttendanceOnce(eventId: String): List<Attendance> =
        dao.getByEventAndStatus(eventId, AttendanceStatus.ABSENT)

    override fun markAllInBatchChunked(
        eventId: String,
        adminId: String,
        children: List<Child>,
        existing: Map<String, Attendance?>,
        status: AttendanceStatus,
        chunkSize: Int
    ): Task<Void> {

        repoScope.launch {
            val now = Timestamp.now()
            val rows = ArrayList<Attendance>(children.size)

            children.forEach { child ->
                val cur = existing[child.childId]
                if (cur?.status == status) return@forEach

                val id = idFor(eventId, child.childId)
                rows += Attendance(
                    attendanceId = id,
                    childId = child.childId,
                    eventId = eventId,
                    adminId = adminId,
                    status = status,
                    notes = cur?.notes ?: "",
                    checkedAt = now,
                    createdAt = cur?.createdAt ?: now,
                    updatedAt = now,
                    isDirty = true,
                    version = (cur?.version ?: 0L) + 1L
                )
            }

            if (rows.isNotEmpty()) {
                // optional: split to smaller chunks if you like
                dao.upsertAll(rows)
                AttendanceSyncScheduler.enqueueNow(appContext)
            }
        }

        return Tasks.forResult(null)
    }

    // üî• Hydrate exactly one event‚Äôs rows from Firestore ‚Üí Room (server truth ‚Üí clean)
    override suspend fun hydrateEvent(eventId: String) = withContext(Dispatchers.IO) {
        val snap = attendanceRef
            .whereEqualTo("eventId", eventId)
            .orderBy("updatedAt", Query.Direction.ASCENDING) // optional but nice for paging consistency
            .get()
            .await()

        val items = snap.documents.mapNotNull { it.toObject(Attendance::class.java) }
        if (items.isNotEmpty()) {
            dao.upsertAll(items.map { it.copy(isDirty = false) })
        }
    }

    /** selects the count of the children based on the eventDate **/

    override suspend fun eligibleCountsForEvent(
        eventId: String,
        eventDate: Timestamp
    ): EligibleCounts {
        val cutoffMs = endOfDayMillis(eventDate)
        val total = dao.countTotalEligibleByCutoff(cutoffMs)

        // If you persist enums as String via TypeConverter, this is fine:
        val presentStatus = AttendanceStatus.PRESENT.name
        // If you persist as Int ordinal -> use AttendanceStatus.PRESENT.ordinal

        val present = dao.countPresentEligibleForEvent(
            eventId = eventId,
            presentStatus = presentStatus,
            cutoffMs = cutoffMs
        )
        return EligibleCounts(totalEligible = total, presentEligible = present)
    }

    private fun endOfDayMillis(ts: Timestamp): Long {
        val cal = Calendar.getInstance()
        cal.time = ts.toDate()
        cal.set(Calendar.HOUR_OF_DAY, 23) // ‚Üê fix here
        cal.set(Calendar.MINUTE, 59)
        cal.set(Calendar.SECOND, 59)
        cal.set(Calendar.MILLISECOND, 999)
        return cal.timeInMillis
    }

}
